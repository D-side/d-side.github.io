---
author: D-side
comments: true
date: 2013-08-20 23:06:38+00:00
layout: post
slug: duel-prolonged
title: 'Дуэль: продление от безысходности'
wordpress_id: 693
categories:
- Новости
---

Итак, в связи с _эпохальным провалом_, мы вынуждены продлить дуэль ещё на один день. Точка отсчёта, как обычно - комментарии дуэлянтов под постом. Начиная с последнего - дедлайн назначается через сутки.

**Причина продления: несоблюдение совместимости с песочницей.** Что печально - с обеих сторон.

Можете ознакомиться с исходниками сами, а я представлю вам ошибки, допущенные дуэлянтами.

### Павел

Похоже, просто не понял, что такое `type_enemy`.

{%highlight c%}    
type_enemy= instance_nearest(x,y,ob_enemy);
{%endhighlight%}

Последует ошибка компиляции. В песочнице отсутствует объект `ob_enemy`, он не указан в правилах.

### Константин

Не успел доделать бота, в связи с чем игровая логика оказалась упакована не в объект, а в скрипты. Но правила действительно не выдвигали требований держать всю логику бота только в объекте (хотя это мой просчёт), но это не всё.

Бот Константина также ходит боками сквозь стены, что против правил. А ещё использует вот такой интересный код:

{%highlight c%} 
switch(object_get_name(object_index)){
case "type_player":
<...>
case "type_enemy":
<...>
}
{%endhighlight%} 

Ни одна из секций case не сработает. Почему? Потому что в песочнице просто нет ресурсов с такими названиями. Это не ресурсы, это локальные переменные объекта.

### Комментарий

Общая ошибка, допущенная у дуэлянтов из-за непонимания того, почему правила сформулированы именно так. В связи с этим у них в песочницах наблюдаются отдельные объекты одного и другого бота. Должен остаться только один!

А как им понять, кто враг? Кто им скажет? Простой ответ - кто-то третий.

Пусть стартоваться матч будет неким другим объектом. Который создаст двух ботов, и назначит их врагами друг друга. Это _может быть_ **один и тот же объект**, но **два разных экземпляра**. Аналогичным способом эти объекты будут запущены в песочнице.

{%highlight c%} 
one = instance_create( ... );
two = instance_create( ... );
one.type_enemy = two;
two.type_enemy = one;
{%endhighlight%} 

Вовсе необязательно, чтобы исходник содержал работоспособную демонстрацию бота. Хотя, скажу честно - это удобно, поскольку позволяет определить совместимость с песочницей сходу.

Ещё одна рекомендация к разработанному коду (не правило, рекомендация) - используйте `type_wall` прямо как ресурс. Т. е. сделайте объект под названием `type_wall` и никуда его не присваивайте. Но с другими объектами так **не надо** делать, если делаете один-единственный объект с ИИ. Используйте локальные переменные, как в приёме выше. С пулями такой трюк не пройдёт (их может быть много, id экземпляров не спасут), придётся всё же создавать два вида пуль.
